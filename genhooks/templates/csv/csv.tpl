// Code generated by entx CSV generator. DO NOT EDIT.
package {{ .PackageName }}
{{- if .EntPackage }}

import (
	"context"
	"fmt"
	"strings"

	"{{ .EntPackage }}"
	"{{ .EntPackage }}/predicate"
{{- range $lookup := .Lookups }}
	"{{ $.EntPackage }}/{{ $lookup.TargetEntity | toLower }}"
{{- end }}
)

// CSVLookupFn is the function signature for CSV reference lookups.
type CSVLookupFn func(ctx context.Context, client *generated.Client, orgID string, values []string) (map[string]string, error)

// CSVCreateFn is the function signature for CSV reference auto-creation.
type CSVCreateFn func(ctx context.Context, client *generated.Client, orgID string, values []string) (map[string]string, error)

// CSVLookupEntry contains the lookup and optional create function for a target entity/match field pair.
type CSVLookupEntry struct {
	Lookup CSVLookupFn
	Create CSVCreateFn
}

// CSVLookupRegistry maps (TargetEntity:MatchField) to lookup/create functions.
var CSVLookupRegistry = map[string]CSVLookupEntry{
{{- range $lookup := .Lookups }}
	"{{ $lookup.TargetEntity }}:{{ $lookup.MatchField }}": {
		Lookup: Lookup{{ $lookup.TargetEntity }}By{{ $lookup.MatchField | toUpperCamel }},
{{- if $lookup.CreateIfMissing }}
		Create: Create{{ $lookup.TargetEntity }}By{{ $lookup.MatchField | toUpperCamel }},
{{- end }}
	},
{{- end }}
}

// GetCSVLookupEntry returns the lookup entry for a target entity and match field.
func GetCSVLookupEntry(targetEntity, matchField string) (CSVLookupEntry, bool) {
	key := targetEntity + ":" + matchField
	entry, ok := CSVLookupRegistry[key]
	return entry, ok
}

// normalizeCSVKey normalizes input values for lookup comparisons.
func normalizeCSVKey(value string) string {
	return strings.ToLower(strings.TrimSpace(value))
}

{{- range $lookup := .Lookups }}

// Lookup{{ $lookup.TargetEntity }}By{{ $lookup.MatchField | toUpperCamel }} resolves {{ $lookup.TargetEntity }} {{ $lookup.MatchField }} values to IDs.
func Lookup{{ $lookup.TargetEntity }}By{{ $lookup.MatchField | toUpperCamel }}(ctx context.Context, client *generated.Client, orgID string, values []string) (map[string]string, error) {
	if len(values) == 0 {
		return nil, nil
	}

	unique := make(map[string]string)
	for _, v := range values {
		v = strings.TrimSpace(v)
		if v == "" {
			continue
		}
		key := normalizeCSVKey(v)
		if _, exists := unique[key]; !exists {
			unique[key] = v
		}
	}

	if len(unique) == 0 {
		return nil, nil
	}

	predicates := make([]predicate.{{ $lookup.TargetEntity }}, 0, len(unique))
	for _, v := range unique {
		predicates = append(predicates, {{ $lookup.TargetEntity | toLower }}.{{ $lookup.MatchField | toUpperCamel }}EqualFold(v))
	}

{{- if $lookup.OrgScoped }}
	records, err := client.{{ $lookup.TargetEntity }}.Query().
		Where({{ $lookup.TargetEntity | toLower }}.OwnerID(orgID), {{ $lookup.TargetEntity | toLower }}.Or(predicates...)).
		All(ctx)
{{- else }}
	records, err := client.{{ $lookup.TargetEntity }}.Query().
		Where({{ $lookup.TargetEntity | toLower }}.Or(predicates...)).
		All(ctx)
{{- end }}
	if err != nil {
		return nil, err
	}

	resolved := make(map[string]string, len(records))
	for _, r := range records {
		key := normalizeCSVKey(r.{{ $lookup.MatchField | toUpperCamel }})
		if existingID, exists := resolved[key]; exists && existingID != r.ID {
			return nil, fmt.Errorf("{{ $lookup.MatchField }} '%s' matched multiple {{ $lookup.TargetEntity }} records; use {{ $lookup.TargetEntity }}ID directly or add additional columns to scope the lookup", r.{{ $lookup.MatchField | toUpperCamel }})
		}
		resolved[key] = r.ID
	}

	return resolved, nil
}
{{- if $lookup.CreateIfMissing }}

// Create{{ $lookup.TargetEntity }}By{{ $lookup.MatchField | toUpperCamel }} creates missing {{ $lookup.TargetEntity }} records and returns their IDs.
func Create{{ $lookup.TargetEntity }}By{{ $lookup.MatchField | toUpperCamel }}(ctx context.Context, client *generated.Client, orgID string, values []string) (map[string]string, error) {
	if len(values) == 0 {
		return nil, nil
	}

	unique := make(map[string]string)
	for _, v := range values {
		v = strings.TrimSpace(v)
		if v == "" {
			continue
		}
		key := normalizeCSVKey(v)
		if _, exists := unique[key]; !exists {
			unique[key] = v
		}
	}

	if len(unique) == 0 {
		return nil, nil
	}

	builders := make([]*generated.{{ $lookup.TargetEntity }}Create, 0, len(unique))
	for _, v := range unique {
{{- if $lookup.OrgScoped }}
		builders = append(builders, client.{{ $lookup.TargetEntity }}.Create().
			Set{{ $lookup.MatchField | toUpperCamel }}(v).
			SetOwnerID(orgID))
{{- else }}
		builders = append(builders, client.{{ $lookup.TargetEntity }}.Create().
			Set{{ $lookup.MatchField | toUpperCamel }}(v))
{{- end }}
	}

	created, err := client.{{ $lookup.TargetEntity }}.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, err
	}

	resolved := make(map[string]string, len(created))
	for _, r := range created {
		key := normalizeCSVKey(r.{{ $lookup.MatchField | toUpperCamel }})
		resolved[key] = r.ID
	}

	return resolved, nil
}
{{- end }}
{{- end }}
{{- end }}

// CSVReferenceRule describes how a CSV column maps to a target ID field.
type CSVReferenceRule struct {
	// SourceColumn is the CSV column name containing friendly values
	SourceColumn string
	// TargetField is the Go field name on the input struct to populate
	TargetField string
	// TargetEntity is the entity type to query (e.g., User, Group)
	TargetEntity string
	// MatchField is the field on the target entity to match (e.g., email, name)
	MatchField string
	// IsSlice indicates if the target field is []string
	IsSlice bool
	// CreateIfMissing allows auto-creation during import
	CreateIfMissing bool
}

// CSVSchemaInfo contains CSV reference metadata for a schema.
type CSVSchemaInfo struct {
	// SchemaName is the ent schema name
	SchemaName string
	// Rules contains the CSV reference rules for this schema
	Rules []CSVReferenceRule
}

// CSVReferenceRegistry maps schema names to their CSV reference info.
var CSVReferenceRegistry = map[string]CSVSchemaInfo{
{{- range $schema := .Schemas }}
	"{{ $schema.Name }}": {
		SchemaName: "{{ $schema.Name }}",
		Rules: []CSVReferenceRule{
{{- range $field := $schema.Fields }}
			{
				SourceColumn:    "{{ $field.CSVColumn }}",
				TargetField:     "{{ $field.GoFieldName }}",
				TargetEntity:    "{{ $field.TargetEntity }}",
				MatchField:      "{{ $field.MatchField }}",
				IsSlice:         {{ $field.IsSlice }},
				CreateIfMissing: {{ $field.CreateIfMissing }},
			},
{{- end }}
		},
	},
{{- end }}
}

// GetCSVReferenceRules returns the CSV reference rules for a schema.
func GetCSVReferenceRules(schemaName string) []CSVReferenceRule {
	info, ok := CSVReferenceRegistry[schemaName]
	if !ok {
		return nil
	}

	return info.Rules
}

// HasCSVReferences returns true if a schema has CSV reference fields.
func HasCSVReferences(schemaName string) bool {
	info, ok := CSVReferenceRegistry[schemaName]
	return ok && len(info.Rules) > 0
}

{{- range $schema := .Schemas }}
{{- if $schema.HasCreateInput }}

// {{ $schema.Name }}CSVInput wraps Create{{ $schema.Name }}Input with CSV reference columns.
type {{ $schema.Name }}CSVInput struct {
{{- if $.EntPackage }}
	Input generated.Create{{ $schema.Name }}Input
{{- else }}
	// Input field requires EntPackage to be configured
	Input any
{{- end }}
{{- range $field := $schema.Fields }}
{{- if $field.IsSlice }}
	{{ $field.CSVColumn }} []string `csv:"{{ $field.CSVColumn }}"`
{{- else }}
	{{ $field.CSVColumn }} string `csv:"{{ $field.CSVColumn }}"`
{{- end }}
{{- end }}
}

// CSVInputWrapper marks {{ $schema.Name }}CSVInput for CSV header preprocessing.
func ({{ $schema.Name }}CSVInput) CSVInputWrapper() {}
{{- end }}
{{- if $schema.HasUpdateInput }}

// {{ $schema.Name }}CSVUpdateInput wraps Update{{ $schema.Name }}Input with CSV reference columns for bulk updates.
type {{ $schema.Name }}CSVUpdateInput struct {
	// ID is the entity ID to update
	ID string `csv:"ID"`
{{- if $.EntPackage }}
	Input generated.Update{{ $schema.Name }}Input
{{- else }}
	// Input field requires EntPackage to be configured
	Input any
{{- end }}
{{- range $field := $schema.Fields }}
{{- if $field.IsSlice }}
	{{ $field.CSVColumn }} []string `csv:"{{ $field.CSVColumn }}"`
{{- else }}
	{{ $field.CSVColumn }} string `csv:"{{ $field.CSVColumn }}"`
{{- end }}
{{- end }}
}

// CSVInputWrapper marks {{ $schema.Name }}CSVUpdateInput for CSV header preprocessing.
func ({{ $schema.Name }}CSVUpdateInput) CSVInputWrapper() {}
{{- end }}
{{- end }}
