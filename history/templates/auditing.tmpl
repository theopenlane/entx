{{/* gotype: entgo.io/ent/entc/gen.Graph */}}

{{ define "auditing" }}
// Code generated by entx.history, DO NOT EDIT.
	{{- $pkg := base $.Config.Package }}
	{{- template "header" $ }}
import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"reflect"
	"time"

	"github.com/theopenlane/entx/history"
	"entgo.io/ent"
	"github.com/rs/zerolog/log"

	{{- range $n := $.Nodes }}
		{{- $name := $n.Name }}
		{{- $history := hasSuffix $name "History" }}
		{{- if $history }}
		"{{ $.Config.Package }}/{{ lower $n.Name }}"
		{{- end }}
	{{- end }}
)

{{ $includeUpdatedBy := $.Annotations.HistoryConfig.IncludeUpdatedBy }}
{{ $updatedByKey := extractUpdatedByKey $.Annotations.HistoryConfig.UpdatedBy }}
{{ $updatedByValueType := extractUpdatedByValueType $.Annotations.HistoryConfig.UpdatedBy }}
{{ $updatedByNillable := $.Annotations.HistoryConfig.UpdatedBy.Nillable }}

type Change struct {
	FieldName string
	Old       any
	New       any
}

// MarshalGQL implement the Marshaler interface for gqlgen
func (c Change) MarshalGQL(w io.Writer) {
	marshalGQLJSON(w, c)
}

// UnmarshalGQL implement the Unmarshaler interface for gqlgen
func (c *Change) UnmarshalGQL(v interface{}) error {
	return unmarshalGQLJSON(v, c)
}

// marshalGQLJSON marshals the given type into JSON and writes it to the given writer
func marshalGQLJSON[T any](w io.Writer, a T) {
	byteData, err := json.Marshal(a)
	if err != nil {
		log.Fatal().Err(err).Msg("error marshalling json object")
	}

	_, err = w.Write(byteData)
	if err != nil {
		log.Fatal().Err(err).Msg("error writing json object")
	}
}

// unmarshalGQLJSON unmarshals a JSON object into the given type
func unmarshalGQLJSON[T any](v any, a T) error {
	byteData, err := json.Marshal(v)
	if err != nil {
		return err
	}

	err = json.Unmarshal(byteData, &a)
	if err != nil {
		return err
	}

	return nil
}

func NewChange(fieldName string, old, new any) Change {
	return Change{
		FieldName: fieldName,
		Old:       old,
		New:       new,
	}
}

type HistoryDiff[T any] struct {
	Old     *T
	New     *T
	Changes []Change
}

// AuditLog is the representation of an audit log entry.
type AuditLog struct {
	// Table is the name of the table that this audit log entry is for.
	Table string `json:"table"`
	// Ref is the reference ID of the object that this audit log entry is for.
	RefID string `json:"id"`
	// HistoryTime is the time when the history entry was created.
	HistoryTime time.Time `json:"time"`
	// Operation is the type of operation that was performed on the object.
	Operation history.OpType `json:"operation"`
	// Changes is a JSON-encoded string containing the changes made to the object.
	Changes []Change `json:"changes"`
	{{- if $includeUpdatedBy }}
	// UpdatedBy is the user who performed the operation.
	UpdatedBy {{ if $updatedByNillable}}*{{- end}}{{ $updatedByValueType }} `json:"updatedBy"`
	{{- end }}
}

var auditlogImplementors = []string{"AuditLog", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*AuditLog) IsNode() {}

// AuditLogEdge is the edge representation of AuditLog.
type AuditLogEdge struct {
	Node   *AuditLog  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// AuditLogConnection is the connection containing edges to AuditLog.
type AuditLogConnection struct {
	Edges      []*AuditLogEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// AuditLogWhereInput is the input type for filtering AuditLog entries
// Table is always required for now due to pagination on a single table
// TODO: (sfunk) use joins to allow for pagination across multiple tables
type AuditLogWhereInput struct {
	RefID     *string    		 `json:"refID,omitempty"`
	UpdatedBy *string   		 `json:"updatedBy,omitempty"`
	Operation *history.OpType    `json:"operation,omitempty"`
	Table     string     		 `json:"table"`
	Before    *time.Time 		 `json:"before,omitempty"`
	After     *time.Time 		 `json:"after,omitempty"`
}


// AuditLogOrderField defines the ordering field of AuditLog.
type AuditLogOrderField struct {
	// Value extracts the ordering value from the given AuditLog.
	Value    func(*AuditLog) (ent.Value, error)
	toCursor func(*AuditLog) Cursor
}

// AuditLogOrder defines the ordering of AuditLog.
type AuditLogOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *AuditLogOrderField `json:"field"`
}

var (
	// AuditLogOrderFieldCreatedAt orders AuditLog by history_time.
	AuditLogOrderFieldHistoryTime= &AuditLogOrderField{
		Value: func(al *AuditLog) (ent.Value, error) {
			return al.HistoryTime, nil
		},
		toCursor: func(al *AuditLog) Cursor {
			return Cursor{
				ID:    al.RefID,
				Value: al.HistoryTime,
			}
		},
	}
)


var (
	MismatchedRefError = errors.New("cannot take diff of histories with different Refs")
	IdenticalHistoryError = errors.New("cannot take diff of identical history")
)

	{{ range $n := $.Nodes }}
		{{ $name := $n.Name }}

		{{ $history := hasSuffix $name "History" }}
		{{ if $history }}
		{{ else }}
			{{ range $h := $.Nodes }}
				{{ $sameNodeType := hasPrefix $h.Name (printf "%sHistory" $n.Name) }}
				{{ if $sameNodeType }}
func ({{ $h.Receiver }} *{{ $h.Name }}) changes(new *{{ $h.Name }}) []Change {
	var changes []Change
{{- range $f := $h.Fields }}
	{{- if not (in $f.StructField (slist "Ref" "HistoryTime" "Operation" "UpdatedBy")) }}
		if !reflect.DeepEqual({{ $h.Receiver }}.{{ $f.StructField }}, new.{{ $f.StructField }}) {
			changes = append(changes, NewChange({{ lower $h.Name }}.Field{{ $f.StructField }} , {{ $h.Receiver }}.{{ $f.StructField }}, new.{{ $f.StructField }}))
		}
	{{- end }}
{{- end }}
	return changes
}

func ({{ $h.Receiver }} *{{ $h.Name }}) Diff(history *{{ $h.Name }}) (*HistoryDiff[{{ $h.Name }}], error) {
	if {{ $h.Receiver }}.Ref != history.Ref {
		return nil, MismatchedRefError
	}

	{{ $h.Receiver }}Unix, historyUnix := {{ $h.Receiver }}.HistoryTime.Unix(), history.HistoryTime.Unix()
	{{ $h.Receiver }}Older := {{ $h.Receiver }}Unix < historyUnix || ({{ $h.Receiver }}Unix == historyUnix && {{ $h.Receiver }}.ID < history.ID)
	historyOlder := {{ $h.Receiver }}Unix > historyUnix || ({{ $h.Receiver }}Unix == historyUnix && {{ $h.Receiver }}.ID > history.ID)

   if {{ $h.Receiver }}Older {
		return &HistoryDiff[{{ $h.Name }}]{
			Old:     {{ $h.Receiver }},
			New:     history,
			Changes: {{ $h.Receiver }}.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[{{ $h.Name }}]{
			Old:     history,
			New:     {{ $h.Receiver }},
			Changes: history.changes({{ $h.Receiver }}),
		}, nil
	}
	return nil, IdenticalHistoryError
}
				{{ end }}
			{{ end }}
		{{ end }}
	{{ end }}

func (c Change) String(op history.OpType) string {
	var newstr, oldstr string
	if c.New != nil {
		val, err := json.Marshal(c.New)
		if err != nil {
			newstr = fmt.Sprintf("%v", c.New)
		} else {
			newstr = string(val)
		}
	}
	if c.Old != nil {
		val, err := json.Marshal(c.Old)
		if err != nil {
			oldstr = fmt.Sprintf("%v", c.Old)
		} else {
			oldstr = string(val)
		}
	}
	switch op {
	case history.OpTypeInsert:
		return fmt.Sprintf("%s: %s", c.FieldName, newstr)
	case history.OpTypeDelete:
		return fmt.Sprintf("%s: %s", c.FieldName, oldstr)
	default:
		return fmt.Sprintf("%s: %s -> %s", c.FieldName, oldstr, newstr)
	}
}

func (c *Client) Audit(ctx context.Context, after *Cursor, first *int, before *Cursor, last *int) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{}

	var record *AuditLogConnection

	{{- range $n := $.Nodes }}
	{{- if (hasSuffix $n.Name "History") }}
	record, err = audit{{ $n.Name }}(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)
	{{ end }}
	{{- end }}

	return result, nil
}

func (c *Client) AuditWithFilter(ctx context.Context, tableName string, after *Cursor, first *int, before *Cursor, last *int, where *AuditLogWhereInput, orderBy *AuditLogOrder) (result *AuditLogConnection, err error) {
	{{- range $n := $.Nodes }}
	{{- if (hasSuffix $n.Name "History") }}
	if where.Table == strings.TrimSuffix("{{ $n.Name }}", "History") {
		// map AuditLogWhereInput to {{ $n.Name }}WhereInput
		whereInput := &{{ $n.Name }}WhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to {{ $n.Name }}Order
		// default to ordering by HistoryTime desc
		orderByInput := &{{ $n.Name }}Order{
			Field:     {{ $n.Name }}OrderFieldHistoryTime,
			Direction: OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = audit{{ $n.Name }}(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	{{- end }}
	{{- end }}

	return
}


func (r *AuditLog) toRow() []string {
	{{- if $includeUpdatedBy }}
	row := make([]string, 6)
	{{- else }}
	row := make([]string, 5)
	{{- end }}

	row[0] = r.Table
	row[1] = fmt.Sprintf("%v", r.RefID)
	row[2] = r.HistoryTime.Format(time.ANSIC)
	row[3] = r.Operation.String()
	for i, change := range r.Changes {
		if i == 0 {
			row[4] = change.String(r.Operation)
			continue
		}
		row[4] = fmt.Sprintf("%s\n%s", row[4], change.String(r.Operation))
	}
	{{- if $includeUpdatedBy }}
	{{- if $updatedByNillable }}
	if r.UpdatedBy != nil {
		row[5] = fmt.Sprintf("%v", *r.UpdatedBy)
	}
	{{- else if (eq $updatedByValueType "string") }}
	if r.UpdatedBy != "" {
		row[5] = fmt.Sprintf("%v", r.UpdatedBy)
	}
	{{- else }}
		if r.UpdatedBy != 0 {
		row[5] = fmt.Sprintf("%v", r.UpdatedBy)
	}
	{{- end}}
	{{- end }}
	return row
}

{{- range $n := $.Nodes }}
{{- if (hasSuffix $n.Name "History") }}

{{- range $h := $.Nodes }}
{{ $sameNodeType := hasPrefix $n.Name (printf "%sHistory" $h.Name) }}
{{- if $sameNodeType }}
type {{ lower $n.Name }}ref struct {
	Ref {{ $h.ID.Type }}
}
{{- end }}
{{- end }}

func audit{{ $n.Name }}(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *{{ $n.Name }}Order, where *{{ $n.Name }}WhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []{{ $n.Name }}PaginateOption{
		With{{ $n.Name }}Order(orderBy),
		With{{ $n.Name }}Filter(where.Filter),
	}


	client := New{{ $n.Name }}Client(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "{{ $n.Name }}",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			{{- if $includeUpdatedBy }}
			UpdatedBy:   curr.Node.UpdatedBy,
			{{- end }}
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&{{ $n.Name }}{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&{{ $n.Name }}{})
		default:
				// Get the previous history entry to calculate the changes
				prev, err := client.Query().
    				Where(
						{{ lower $n.Name }}.Ref(curr.Node.Ref),
						{{ lower $n.Name }}.HistoryTimeLT(curr.Node.HistoryTime),
						).
					Order({{ lower $n.Name }}.ByHistoryTime(sql.OrderDesc())).
					Limit(1).
					All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
				if err != nil {
					return nil, err
				}

				// this shouldn't happen because the initial change will always be an insert
				// but just in case, we will handle it gracefully
				if len(prev) == 0 {
					prev = append(prev, &{{ $n.Name }}{})
				}

				record.Changes = prev[0].changes(curr.Node)
			}

			edge := &AuditLogEdge{
				Node: record,
				// we only currently support pagination from the same table, so we can use the existing cursor
				Cursor:curr.Cursor,
			}

			result.Edges = append(result.Edges, edge)
		}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

{{- end }}
{{- end }}
{{ end }}
