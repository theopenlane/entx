package entx

import (
	"bytes"
	"fmt"
	"os"
	"sort"
	"text/template"

	"entgo.io/ent/entc"
	"entgo.io/ent/entc/gen"
	"github.com/stoewer/go-strcase"
	"golang.org/x/tools/imports"
)

// ExportableGenerator handles the generation of exportable schema validation.
//
// This generator scans ent schemas for the Exportable annotation and generates
// validation code that can be used to verify export requests.
//
// Usage:
//
//	// In your entc.go file:
//	generator := entx.NewExportableGenerator("./schema", "./internal/hooks")
//	err := generator.Generate()
//	if err != nil {
//		log.Fatal(err)
//	}
//
// The generator will create a file with functions like:
//
//	func IsSchemaExportable(schemaName string) bool {
//		return ExportableSchemas[strings.ToLower(schemaName)]
//	}
//
//	func ValidateExportType(exportType string) error {
//		// Returns error if schema is not exportable
//	}
//
// Example schema annotation:
//
//	func (MySchema) Annotations() []schema.Annotation {
//		return []schema.Annotation{
//			entx.Exportable{}, // Marks this schema as exportable
//		}
//	}
type ExportableGenerator struct {
	// SchemaPath is the path to the schema directory
	SchemaPath string
	// OutputDir is the directory where the generated file will be written
	OutputDir string
	// Package is the package name for the generated file
	Package string
	// ImportPath is the import path for the enums package
	ImportPath string
}

// NewExportableGenerator creates a new ExportableGenerator with default settings.
func NewExportableGenerator(schemaPath, outputDir string) *ExportableGenerator {
	return &ExportableGenerator{
		SchemaPath: schemaPath,
		OutputDir:  outputDir,
		Package:    "hooks",
		ImportPath: "github.com/theopenlane/core/common/enums",
	}
}

// WithPackage sets the package name for the generated file.
func (e *ExportableGenerator) WithPackage(pkg string) *ExportableGenerator {
	e.Package = pkg
	return e
}

// WithImportPath sets the import path for the enums package.
func (e *ExportableGenerator) WithImportPath(importPath string) *ExportableGenerator {
	e.ImportPath = importPath
	return e
}

const exportableGeneratedFileTemplate = `// Code generated by entx. DO NOT EDIT.

package {{.Package}}

import (
	"fmt"
	"strings"
)

// ExportableSchemas contains all schemas that have Exportable annotation
var ExportableSchemas = map[string]bool{
{{range .Schemas}}	"{{.}}": true,
{{end}}}

// IsSchemaExportable checks if a schema name is exportable
func IsSchemaExportable(schemaName string) bool {
	return ExportableSchemas[schemaName]
}

// ValidateExportType validates that an export type corresponds to an exportable schema
func ValidateExportType(exportType string) error {
	if !IsSchemaExportable(exportType) {
		return fmt.Errorf("invalid export type provided ( %s )", exportType)
	}
	return nil
}
`

// Generate generates the exportable schemas validation code and ExportType enum.
func (e *ExportableGenerator) Generate(flags ...string) error {
	graph, err := entc.LoadGraph(e.SchemaPath, &gen.Config{
		BuildFlags: flags,
	})
	if err != nil {
		return fmt.Errorf("loading graph: %w", err)
	}

	schemas := e.findExportableSchemas(graph)

	err = e.generateValidationFile(schemas)
	if err != nil {
		return err
	}

	return nil
}

func (e *ExportableGenerator) findExportableSchemas(graph *gen.Graph) []string {
	var exportableSchemas []string

	ant := &Exportable{}

	for _, schema := range graph.Schemas {
		if raw, ok := schema.Annotations[ant.Name()]; ok {
			if err := ant.Decode(raw); err == nil {
				exportableSchemas = append(exportableSchemas, strcase.UpperSnakeCase(schema.Name))
			}
		}
	}

	sort.Strings(exportableSchemas)

	return exportableSchemas
}

func (e *ExportableGenerator) generateValidationFile(schemas []string) error {
	tmpl, err := template.New("generated").Parse(exportableGeneratedFileTemplate)
	if err != nil {
		return err
	}

	filePath := fmt.Sprintf("%s/exportable_generated.go", e.OutputDir)

	file, err := os.Create(filePath)
	if err != nil {
		return err
	}

	defer file.Close()

	data := struct {
		Package    string
		ImportPath string
		Schemas    []string
	}{
		Package:    e.Package,
		ImportPath: e.ImportPath,
		Schemas:    schemas,
	}

	var buf bytes.Buffer
	if err := tmpl.ExecuteTemplate(&buf, "generated", data); err != nil {
		return err
	}

	// run gofmt and goimports on the file contents
	formatted, err := imports.Process(filePath, buf.Bytes(), nil)
	if err != nil {
		return fmt.Errorf("%w: failed to format file", err)
	}

	if _, err := file.Write(formatted); err != nil {
		return err
	}

	return nil
}
